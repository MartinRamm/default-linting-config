## Default Setup includes:

* typescript (obviously)
* quasar (which uses vue 2)
* purify-ts
* vue-i18n
* vue-i18n-extract
* vuex
* vuex-class-modules
* zod

Linting:

* eslint
  * eslint-config-prettier
  * eslint-plugin-filenames
  * eslint-plugin-folders
  * eslint-plugin-import
  * eslint-plugin-prettier
  * eslint-plugin-ts-immutable
  * eslint-plugin-vue
* prettier
* stylelint
  * stylelint-config-prettier
  * stylelint-config-rational-order
  * stylelint-config-sass-guidelines
  * stylelint-csstree-validator
  * stylelint-no-nested-media
  * stylelint-no-px
  * stylelint-order
  * stylelint-prettier
  * stylelint-use-nesting
* [generateLicenseAttributionsList] Custom code to lint the licences of dependencies that are included in the webpack bundle (generated by quasar). This 
  also creates a "license-data.json" file that is used by the frontend for a "third party attributions" page.
  This requires that you set `build.analyze` of the quasar config to:
  ```js
    {
      analyzerMode: 'json',
      openAnalyzer: false,
      generateStatsFile: true,
      statsOptions: {
        all: true,
        assets: true,
        builtAt: false,
        cached: false,
        cachedAssets: false,
        children: true,
        chunkGroups: false,
        chunkModules: false,
        chunkOrigins: false,
        chunks: true,
        depth: 99,
        entrypoints: true,
        env: false,
        errors: false,
        errorDetails: false,
        hash: false,
        modules: false,
        moduleTrace: false,
        publicPath: true,
        reasons: false,
        source: false,
        timings: false,
        version: false,
        warnings: false,
        usedExports: false,
        performance: false,
        providedExports: false,
      },
    }
  ```
* [translations-missing.bash] Custom code to linting of missing translations
* [translations-syntax.js] Custom code to linting of translations syntax
* actually building the app with quasar

## Coding conventions explained in the README file:

## Coding Conventions
### Data Flow (Flux Pattern)
Data flow between components is based loosely around the `FLUX` pattern Facebook initially created for large frontend
applications. In a nutshell:
* With exception to very few cases, all state is stored in the [Vuex-Store](./src/store/VuexStore.ts). The store is
  split into multiple modules (like e.g. the [AuthenticationStatusStore](./src/store/authenticationTokenStore.ts)).
* The component status is derived only from the store status.
* The component may call service methods (in the FLUX pattern they are called `actions`, in this project we call them
  `services`), that change the store status, that then change the component.
* The architecture used in this project does not make use of a `dispatcher` (as seen in the FLUX pattern).

This one-way data flow may sound a bit restrictive in the beginning, but it has been proven to be highly scalable and
very flexible to changes.

Let's look at a (highly simplified) example that looks at how the error messages on the login screen are set.

The ENUM defines the available states:
```ts
// src/store/LOGIN_ERROR_ENUM.ts
export enum LOGIN_ERROR_ENUM {
  NONE,
  FRONTEND_VALIDATION_FAILED_USERNAME,
  FRONTEND_VALIDATION_FAILED_PASSWORD,
  FRONTEND_VALIDATION_FAILED_USERNAME_AND_PASSWORD,
  BACKEND_VALIDATION_FAILED,
  INVALID_RESPONSE
}
```

The Vuex module defines where the current state is defined, with a simple getter and setters. Note that these components
are grouped by domain - i.e. the store module is not called `LoginPageStore`, but rather `AuthenticationStatusStore` and
contains all related fields.

While it is acceptable to have one setter for multiple fields in the same vuex module, stores may not know about each
other. This logic should be done in a service (next component).
```ts
// ./src/store/authenticationTokenStore.ts
import { Module, Mutation, VuexModule } from 'vuex-class-modules';
import { store } from './VuexStore';
import { LOGIN_ERROR_ENUM } from 'src/store/LOGIN_ERROR_ENUM';

@Module
class AuthenticationStatusStore extends VuexModule {
  private loginError: LOGIN_ERROR_ENUM = LOGIN_ERROR_ENUM.NONE;

  get getLoginError() {
    return this.loginError;
  }

  @Mutation
  setLoginError(loginError: LOGIN_ERROR_ENUM) {
    this.loginError = loginError;
  }
}

export const authenticationTokenStore = new AuthenticationTokenStore({
  store,
  name: 'store.api.auth.tokens',
});
```

Then there is a service (that is again named according to the domain it represents) that can alter these states.
Services decide what part(s) of the vuex store should be changed, when an action is executed.

```ts
// ./src/service/authService.ts
import { authenticationStatusStore } from 'src/store/authenticationStatusStore';
import { z } from 'zod';
import { generateLoginApiRequest } from 'src/api/auth/generateLoginApiRequest';

export const authService = {
  login: (userInput: {username?: string, password?: string}) => {
    // highly simplified example, focusing only on the login error.

    //while validating the inputs, remove previous error messages
    authenticationStatusStore.setLoginError(LOGIN_ERROR_ENUM.NONE);

    //in this example, frontend validation is done with the `zod` library.
    const emailParser = z.preprocess(trimIfString, z.string().email());
    const emailParseResult = emailParser.safeParseAsync(loginInput.username);

    const passwordParser = z.string().nonempty();
    const passwordParseResult = passwordParser.safeParseAsync(loginInput.password);

    Promise.all([emailParseResult, passwordParseResult]).then((result) => {
        const emailResult = result[0];
        const passwordResult = result[1];

        if (!emailResult.success && !passwordResult.success) { //frontend validation failed for both email and password
          authenticationStatusStore.setLoginError(
            LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_USERNAME_AND_PASSWORD
          );
        } else if (!emailResult.success) { //frontend validation failed for email
          authenticationStatusStore.setLoginError(
            LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_USERNAME
          );
        } else if (!passwordResult.success) { //frontend validation failed for password
          authenticationStatusStore.setLoginError(
            LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_PASSWORD
          );
        } else {
          const loginData = {
            username: emailResult.data,
            password: passwordResult.data,
          };
          generateLoginApiRequest(loginData)
            .send() //this sends a HTTP request to the server
            .then((response) =>
              response.handle({ //handle takes an object of functions and, depending on the response from the server, execute one of the functions.
                wrongUsernameOrPassword: () => { //i.e. this function is executed if and only if the response from the server matches the response specification of `wrongUsernameOrPassword` (specified in `generateLoginApiRequest`)
                  authenticationStatusStore.setLoginError(
                    LOGIN_ERROR_ENUM.BACKEND_VALIDATION_FAILED
                  );
                },
                loginSuccessful: (response) => {
                  //not shown. a different attribute of the authenticationStatusStore is changed to swtich pages.
                },
                '*': () => { //this function is executed if the response from the server doesn't match any of the given response specifications
                  authenticationStatusStore.setLoginError(
                    LOGIN_ERROR_ENUM.INVALID_RESPONSE
                  );
                },
              })
            );
        }
      });
  },
};
```

Finally, the vuex component uses the store to decide what error message the user sees, and calls a service function when
the user presses the login button.

```vue
<!-- ./src/components/pages/LoginPage.vue -->
<!-- this example is highly simplified! -->

<template>
  <div id="login">
    <input id="usernameInput" type="text" />
    <span id="usernameError">{{ usernameError }}</span>

    <input id="passwordInput" type="password" />
    <span id="passwordError">{{ passwordError }}</span>

  <button @click.prevent="attemptLogin"></button>
  </div>
</template>

<script lang="ts">
  import { defineComponent } from '@vue/composition-api';
  import { authenticationStatusStore } from 'src/store/authenticationStatusStore';
  import { LOGIN_ERROR_ENUM } from 'src/store/LOGIN_ERROR_ENUM';
  import { authService } from 'src/service/authService';

  export const LoginPage = defineComponent({
    name: 'LoginPage',
    computed: {
      // this value is automatically updated everytime the store status changes. you don't have to take care of this.
      // the return value of this function is used in the template and displays the error message of the username input
      usernameError() {
        return [
          LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_USERNAME,
          LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_USERNAME_AND_PASSWORD,
        ].includes(authenticationStatusStore.getLoginError)
          ? this.$i18n.t('Please enter a valid email address')
          : '';
      },
      // this value is automatically updated everytime the store status changes. you don't have to take care of this.
      // the return value of this function is used in the template and displays the error message of the password input
      passwordError() {
        const loginErrorState = authenticationStatusStore.getLoginError;
        return [
          LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_PASSWORD,
          LOGIN_ERROR_ENUM.FRONTEND_VALIDATION_FAILED_USERNAME_AND_PASSWORD,
        ].includes(loginErrorState)
          ? this.$i18n.t('Please enter a password')
          : loginErrorState === LOGIN_ERROR_ENUM.BACKEND_VALIDATION_FAILED
          ? this.$i18n.t('Invalid Username or Password')
          : loginErrorState === LOGIN_ERROR_ENUM.INVALID_RESPONSE
          ? this.$i18n.t(
              'An unknown error occurred. If you continue seeing this problem, please contact support.'
            )
          : '';
      },
    },
    methods: {
      //this function is executed when the user presses on the login button. The called function is expected to change
      //the store values. notice how the vue component doesn't do this itsself! it only reads from the store
      attemptLogin() {
        authService.login({
          username: document.querySelector('#login #usernameInput').value,
          password: document.querySelector('#login #passwordInput').value,
        });
      },
    },
  });
  export default LoginPage;
</script>
```

### Vue Component Organization
The vue components are organized in the following way:

#### `src/components/layout`
A layout is a component that arranges or lays out content. It is use-case agnostic, so it only contains
images, background colors, etc. and declares a place to place the actual content (text, buttons, etc.). This is usually
provided via [one](https://vuejs.org/v2/guide/components-slots.html) or
[more slots](https://vuejs.org/v2/guide/components-slots.html#Named-Slots) when using the component. The component will
likely contain props to fine-tune the layout.

#### `src/components/template`
A template is the next step from a layout. It is not use-case agnostic, it may contain business logic, but it is not
complete yet, as it still declares a place to place more specific content (via slots and properties, and above).

#### `src/components/pages`
The pages folder contains complete pages that are usually displayed by the router. Pages are usually
based on layouts and optionally the `src/components/AuthenticationWrapper` (see seperate sections below for these
categories).

Please read about how links to pages should be generated in the `Coding Conventions` --> `Links` section.

#### `src/components/partial`
Here, reusable components are created that can be used anywhere. This folder contains more sub-folders that further
group this category of components.

#### `src/components/AuthenticationWrapper`
This is a special wrapper that properly handles the authentication status. The slot you provide to it is only displayed
when the user is successfully authenticated. Else, it properly handles the other states defined by the
`src/store/authenticationStatusStore.ts`.

### Links
Hardcoding links can cause errors (sending users to 404 pages, typos, etc.) and complications when refactoring. Hence,
programmers should never hardcode urls as shown below:
```html
<!-- LoginPage.vue -->
<a href="#/password-reset">Password Reset</a> <!--DO NOT DO THIS!!-->
```

Instead, each Page component (see `Vue Component Organization` section) that can be navigated to from a URL is expected
to export a string (if no params are required) or a function (if params are required) that generates an appropriate
link, as shown below:

```vue
<!-- PasswordResetPage.vue -->
<script lang="ts">
  //...
  export const PasswordResetPage = defineComponent(...);
  export default PasswordResetPage;

  export const passwordResetLink = '#/password-reset'; //for non-parameterized urls
  export const passwordResetLink = (userId: string) => `#/password-reset?for=${encodeURIComponent(userId)}`; //for parameterized urls
</script>

<!-- LoginPage.vue -->
<template>
  <a :href="link.passwordReset">Password Reset</a> <!--DO THIS!!-->
</template>

<script lang="ts">
  import {passwordResetLink} from 'PasswordResetPage.vue';
  //...
  //...
  export const LoginPage = defineComponent({
    ...,
    computed: {
      links: () => ({
        passwordResetLink,
      })
    }
  });
  export default LoginPage;
</script>
```

along with a `RouteConfig` that needs to be registered in `src/router/routes`:
```vue
<!-- PasswordResetPage.vue -->
<script lang="ts">
  import { RouteConfig } from 'vue-router';
  //...
  export const PasswordResetPage = defineComponent(...);

  export const passwordResetLink = '#/password-reset'; //for non-parameterized urls
  export const passwordResetRouteConfig: RouteConfig = {
    path: '/password-reset',
    component: PasswordResetPage,
  };
  export default PasswordResetPage;
</script>
```
```ts
import { RouteConfig } from 'vue-router';
import { passwordResetRouteConfig } from 'src/components/pages/PasswordResetPage.vue'

export const routes: RouteConfig[] = [
  passwordResetRouteConfig,
  ...
];
```

### Translations
#### Static translation:
```ts
$t('Static Translation')
```
#### Inject values:
```ts
$t('Hello, {name}', {name: 'Jan'})
```
#### Inject values with translation/link:
```vue
<i18n path="I agree to the {terms-and-conditions}" tag="p" >
  <template v-slot:terms-and-conditions>
    <a href="/terms-and-conditions">{{ $t('terms and conditions') }}</a>
  </template>
</i18n>

<!-- Output: <p>I agree to the <a href="/terms-and-conditions">terms and conditions</a></p> -->
```
NOTE!! Until [this bug](https://github.com/kazupon/vue-i18n/issues/1195) is fixed, this will only work if you add a
translation for the `I agree to the {terms-and-conditions}` string!
#### Pluralization
```ts
$tc('no apples | one apple | {count} apples', 0) //no apples
$tc('no apples | one apple | {count} apples', 1) //one apple
$tc('no apples | one apple | {count} apples', 2) //2 apples
$tc('no apples | one apple | {count} apples', 3) //3 apples
```
#### Numbers
Remember that e.g. numbers are displayed differently in different locales (de-DE: `123.456,00` vs. en-US: `123,456.00`
vs.hi-IN: `1,23,456.00` , hence it is important that these are also formatted using the l18n tool.

Please note that there are not just differences in the numbers, but also where units or percentage symbols are shown
(de-DE: `14 %`, en-US: `14%`, tr-TR: `%14`).

The options are derived from the `Intl` component, for more detailed documentation see
[here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat).

!!!See next section for handling measurements!!!

Each example below shows the formatting available in the `typescript` and `vue` context.
```vue
<!-- Output: <p>123,456,789.00</p> -->
<p>{{ $n(123456789, {minimumFractionDigits: 2}) }}</p>
<i18n-n tag="p" :value="123456789" :format="{minimumFractionDigits: 2}" />

<!-- Output: <p>123,456,789</p> -->
<p>{{ $n(123456789, {maximumFractionDigits: 2}) }}</p>
<i18n-n tag="p" :value="123456789" :format="{maximumFractionDigits: 2}" />

<!-- Output: <p>123,456,789.34</p> -->
<p>{{ $n(123456789.34, {maximumFractionDigits: 2}) }}</p>
<i18n-n tag="p" :value="34" :format="{maximumFractionDigits: 2}" />

<!-- Output: <p>123,456,789.35</p> -->
<p>{{ $n(123456789.345, {maximumFractionDigits: 2}) }}</p>
<i18n-n tag="p" :value="345" :format="{maximumFractionDigits: 2}" />

<!-- Output: <p>14 %</p> -->
<p>{{ $n(0.143, {style: 'percent'}) }}</p>
<i18n-n tag="p" :value="0.143" :format="{style: 'percent'}" />

<!-- Output: <p>14%</p> -->
<p>{{ $n(0.14, {style: 'percent', maximumFractionDigits: 1}) }}</p>
<i18n-n tag="p" :value="0.14" :format="{style: 'percent', maximumFractionDigits: 1}" />

<!-- Output: <p>14.6%</p> -->
<p>{{ $n(0.146, {style: 'percent', maximumFractionDigits: 1}) }}</p>
<i18n-n tag="p" :value="0.146" :format="{style: 'percent', maximumFractionDigits: 1}" />

<!-- Output: <p>14.7%</p> -->
<p>{{ $n(0.1468, {style: 'percent', maximumFractionDigits: 1}) }}</p>
<i18n-n tag="p" :value="0.1468" :format="{style: 'percent', maximumFractionDigits: 1}" />
```

The same goes for units (e.g. `km/h`). Not just the placement, but also the abbreviations used, may change.
[This list](https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-issanctionedsimpleunitidentifier)
of units are supported. Units may be chained using `{unit1}-per-{unit2}`, e.g.: `kilometer-per-hour`.
```vue
<!-- Output: <p>123 kb/s</p> -->
<p>{{ $n(123, {style: 'unit', unit: 'kilobit-per-second'}) }}</p>
<i18n-n tag="p" :value="123" :format="{style: 'unit', unit: 'kilobit-per-second'}" />

<!-- Output: <p>123 hr</p> -->
<p>{{ $n(123, {style: 'unit', unit: 'hour'}) }}</p>
<i18n-n tag="p" :value="123" :format="{style: 'unit', unit: 'hour'}" />

<!-- Output: <p>123 hours</p> -->
<p>{{ $n(123, {style: 'unit', unit: 'hour', unitDisplay: 'long'}) }}</p>
<i18n-n tag="p" :value="123" :format="{style: 'unit', unit: 'hour', unitDisplay: 'long'}" />

<!-- Output: <p>1 hour</p> -->
<p>{{ $n(1, {style: 'unit', unit: 'hour', unitDisplay: 'long'}) }}</p>
<i18n-n tag="p" :value="1" :format="{style: 'unit', unit: 'hour', unitDisplay: 'long'}" />

<!-- Output: <p>1h</p> -->
<p>{{ $n(1, {style: 'unit', unit: 'hour', unitDisplay: 'narrow'}) }}</p>
<i18n-n tag="p" :value="1" :format="{style: 'unit', unit: 'hour', unitDisplay: 'narrow'}" />
```

### Logging
Debugging is easier if you add lots of log statements. Plese use the logger often with the apropriate log level:
```ts
import { generateLogger } from 'src/util/logging/generateLogger';

const logger = generateLogger('Component<Name>'); //or Page<Name>, Vue<VueComponent>, Util<UtilFnName>, etc.
logger.debug('debug log message');
```
or (not recommended)
```ts
import { debug } from 'src/util/logging/generateLogger'
debug('debug log message');
```

### Errors
Custom errors should be placed into the `/src/errors` folder and extend the base error `MonitorFishError`. Don't
differentiate between errors by using different strings, instead, create a custom error and throw it.

Instead of
```ts
Left(new Error('Unknown Page ' + name));
```
use
```ts
//place in `src/errors/UnknownPageError.ts`
import {MonitorFishError} from "./MonitorFishError";
export class UnknownPageError extends MonitorFishError {
    public readonly pageName;
    constructor(pageName: string) {
        super('Unknown Page ' + name);
        this.pageName = pageName;
    }
}
//usage
import {UnknownPageError} from "src/errors/UnknownPageError";
Left(new UnknownPageError(page));
```

### Maybe instead of returning undefined
Instead of a function returning a value or `undefined | null`, programers are encouraged to use `Maybe`, see
https://gigobyte.github.io/purify/adts/Maybe.

Instead of
```ts
export const getConfig = (): Config | undefined => {...};

//usage
const config = getConfig();
if (!config) {
  config = ...;
}
```
use
```ts
import { Maybe, Just, Nothing } from 'purify-ts/Maybe';

const config = ...;

//explicit
export const getConfig: Maybe<Config> = () => {
  if (config) {
    return Just(config);
  }
  return Nothing();
}
//shorthand:
export const getConfig: Maybe<Config> = () => Maybe.fromNullable(config);

//usage
config = getConfig.orDefault(defaultConfig);
```

There are many more things you can do with Maybe than just `orDefault`, please consult the
[documentation](https://gigobyte.github.io/purify/adts/Maybe) for them.

### Either instead of throwing errors
Do not throw errors! Instead, return an `Either` for properly typing errors. Currently, you
can't type errors a function may throw, which makes error handling more complex. An Either is an object that either has
a "left" value (indicating error), or a right value (indicating success, as "right is always right"
(except in politics!!).

Instead of:
```ts
export const getConfig = (): Config => {
 const db = getDbConnection();
  if (!db) {
   throw new DbNotReachableException(); //DO NOT DO THIS!! (eslint won't let you anyway...)
  }

  const config = db.getConfig();
  if (!config) {
    throw new ConfigNotFoundException(); //DO NOT DO THIS!! (eslint won't let you anyway...)
  }

  return config;
};

//usage
try {
  const config = getConfig();
  useConfig(config);
} catch (error: any) {
  handleConfigError(error)
}
//error is of type `any` - it is not possible to derive that it is either `DbNotReachableException` or `ConfigNotFoundException`
```

use:
```ts
import { Either, Left, Right } from 'purify-ts/Either'

type GetConfigErrors = DbNotReachableException | ConfigNotFoundException;
const getConfig = (): Either<GetConfigErrors, Config> => {
  const db = getDbConnection();
  if (!db) {
    return Left(new DbNotReachableException());
  }

  const config = db.getConfig();
  if (!config) {
    return Left(new ConfigNotFoundException());
  }

  return Right(config);
}

const config = getConfig();
config.caseOf(
  (error: GetConfigErrors) => handleConfigError(error), //error is not of type `any` anymore!
  (config: Config) => useConfig(config)
);
```

There are lots more useful functions in Either, you should read the [docs](https://gigobyte.github.io/purify/adts/Either).

An eslint rule will force you to do this.

### Promises should always resolve an `Either`
The idea above also extends to promises. Promises that have an error state should always resolve to an `Either`, that
 clearly types the errors.

Instead of:
```ts
export const getConfig = (): Promise<Config> => new Promise(async () => {
  let db;
  try {
   db = await getDbConnection();
  } catch {
    return Promise.reject(new DbNotReachableException()); //DO NOT DO THIS!! (eslint won't let you anyway...)
  }

  let config;
  try {
    config = await db.getConfig();
  } catch {
    return Promise.reject(new ConfigNotFoundException()); //DO NOT DO THIS!! (eslint won't let you anyway...)
  }

  return config;
});

getConfig
  .then(...)
  .catch((error: any) => ...)
//error is of type `any` - it is not possible to derive that it is either `DbNotReachableException` or `ConfigNotFoundException`
```

Use:
```ts
import { Either, Left, Right } from 'purify-ts/Either'
import { EitherAsync } from "purify-ts/EitherAsync";

type GetConfigErrors = DbNotReachableException | ConfigNotFoundException;
const getConfig = (): Promise<Either<GetConfigErrors, Config>> => EitherAsync<GetConfigErrors, Config>( async ({throwE}) => {
  let db;
  try {
    db = await getDbConnection();
  } catch {
    return throwE(new DbNotReachableException());
  }

  let config;
  try {
    config = await db.getConfig();
  } catch {
    return throwE(new ConfigNotFoundException());
  }

  return config;
}).run();


getConfig
  .then(result => result.caseOf(
    (error: GetConfigErrors) => handleConfigError(error), //error is not of type `any` anymore!
    (config: Config) => useConfig(config)
  ));
```

An eslint rule will force you to do this.

### Immutable objects and arrays
Especially when working with vue, mutating objects is a really bad idea. Why? Because a mutated object doesn't trigger
component updates, only replacing them does.

Lets assume:
```ts
//Example Vuex Store
class Store extends VuexModule {
  correctImplementation = {
    name: "Jan",
    otherValue: 'ignore'
  };

  incorrectImplementation = {
    name: "Jan",
    otherValue: 'ignore'
  };

  @Mutation
  private correctMutation(newName: string) {
    this.correctImplementation = {...this.correctImplementation, name: newName};
  }

  @Mutation
  private incorrectMutation(newName: string) {
     this.correctImplementation.name = newName; //DO NOT DO THIS!! (eslint won't let you anyway...)
  }
}

export const store = new Store(...);
```
is used with a Vue component like this:
```vue
<template>
  <div>
    <p>{{correctImplementation.name}}</p>
    <p>{{incorrectImplementation.name}}</p>
  </div>
</template>

<script lang="ts">
import {store} from '...';

export const VuePage = defineComponent({
  computed: {
    correctImplementation() {
      return store.correctImplementation;
    },
    incorrectImplementation() {
      return store.incorrectImplementation;
    },
  },
});
export default VuePage;
</script>
```
If you call the `correctMutation` function, the component updates as expected. But if you call the `incorrectMutation`
function, the component will not update. Why? Because the component basically watches the pointer of the object and only
triggers an update, when the pointer changes. The `correctMutation` object creates a shallow copy with the new name,
while `incorrectMutation` edits the object.

For this reason, and others (just one example: mutability as a side effect of functions very often cause bugs),
mutability of objects (not TOP LEVEL CLASS PARAMETERS) and arrays has been disabled via a eslint rule.

## Third-Party Attributions
All software that is distributed as part of the bundle generated by quasar (plus some of the tools used to create these
bundles) are attributed for in the third party attribution page. For this to work, the webpack bundle as well as the
`src-cordova package.json` file is analyzed via `bin/generateLicenseAttributionsList.js`. This step generates a
`license-data.json` file, that is placed in the `dist` folder. The Vue component showing this data then fetches it
from this file (as the webpack build is already finished, when this script runs).

Please note that this script also checks that the modules used are licenses in a way that they are allowed to be
distributed.
